"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Index = void 0;

var _iteratee = _interopRequireDefault(require("lodash/iteratee"));

var _clearObject = _interopRequireDefault(require("./clear-object"));

var _isEmpty = _interopRequireDefault(require("./is-empty"));

var _notImplemented = _interopRequireDefault(require("./not-implemented"));

var _collection = require("./collection");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class Index {
  constructor(computeHash) {
    if (computeHash) {
      this.computeHash = (0, _iteratee.default)(computeHash);
    }

    this._itemsByHash = Object.create(null);
    this._keysToHash = Object.create(null);
    this._onAdd = this._onAdd.bind(this);
    this._onUpdate = this._onUpdate.bind(this);
    this._onRemove = this._onRemove.bind(this);
  }

  computeHash(value, key) {
    throw new _notImplemented.default('this method must be overridden');
  }

  sweep() {
    const itemsByHash = this._itemsByHash;

    for (const hash in itemsByHash) {
      if ((0, _isEmpty.default)(itemsByHash[hash])) {
        delete itemsByHash[hash];
      }
    }
  }

  get items() {
    return this._itemsByHash;
  }

  _attachCollection(collection) {
    this._onAdd(collection.all);

    collection.on(_collection.ACTION_ADD, this._onAdd);
    collection.on(_collection.ACTION_UPDATE, this._onUpdate);
    collection.on(_collection.ACTION_REMOVE, this._onRemove);
  }

  _detachCollection(collection) {
    collection.removeListener(_collection.ACTION_ADD, this._onAdd);
    collection.removeListener(_collection.ACTION_UPDATE, this._onUpdate);
    collection.removeListener(_collection.ACTION_REMOVE, this._onRemove);
    (0, _clearObject.default)(this._itemsByHash);
    (0, _clearObject.default)(this._keysToHash);
  }

  _onAdd(items) {
    const computeHash = this.computeHash,
          itemsByHash = this._itemsByHash,
          keysToHash = this._keysToHash;

    for (const key in items) {
      const value = items[key];
      const hash = computeHash(value, key);

      if (hash != null) {
        ;
        (itemsByHash[hash] || (itemsByHash[hash] = {}))[key] = value;
        keysToHash[key] = hash;
      }
    }
  }

  _onUpdate(items) {
    const computeHash = this.computeHash,
          itemsByHash = this._itemsByHash,
          keysToHash = this._keysToHash;

    for (const key in items) {
      const value = items[key];
      const prev = keysToHash[key];
      const hash = computeHash(value, key);
      if (prev != null) delete itemsByHash[prev][key];

      if (hash != null) {
        ;
        (itemsByHash[hash] || (itemsByHash[hash] = {}))[key] = value;
        keysToHash[key] = hash;
      } else {
        delete keysToHash[key];
      }
    }
  }

  _onRemove(items) {
    const itemsByHash = this._itemsByHash,
          keysToHash = this._keysToHash;

    for (const key in items) {
      const prev = keysToHash[key];

      if (prev != null) {
        delete itemsByHash[prev][key];
        delete keysToHash[key];
      }
    }
  }

}

exports.Index = Index;
//# sourceMappingURL=index.js.map