"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UniqueIndex = void 0;

var _iteratee = _interopRequireDefault(require("lodash/iteratee"));

var _clearObject = _interopRequireDefault(require("./clear-object"));

var _notImplemented = _interopRequireDefault(require("./not-implemented"));

var _collection = require("./collection");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class UniqueIndex {
  constructor(computeHash) {
    if (computeHash) {
      this.computeHash = (0, _iteratee.default)(computeHash);
    }

    this._itemByHash = Object.create(null);
    this._keysToHash = Object.create(null);
    this._onAdd = this._onAdd.bind(this);
    this._onUpdate = this._onUpdate.bind(this);
    this._onRemove = this._onRemove.bind(this);
  }

  computeHash(value, key) {
    throw new _notImplemented.default('this method must be overridden');
  }

  get items() {
    return this._itemByHash;
  }

  _attachCollection(collection) {
    this._onAdd(collection.all);

    collection.on(_collection.ACTION_ADD, this._onAdd);
    collection.on(_collection.ACTION_UPDATE, this._onUpdate);
    collection.on(_collection.ACTION_REMOVE, this._onRemove);
  }

  _detachCollection(collection) {
    collection.removeListener(_collection.ACTION_ADD, this._onAdd);
    collection.removeListener(_collection.ACTION_UPDATE, this._onUpdate);
    collection.removeListener(_collection.ACTION_REMOVE, this._onRemove);
    (0, _clearObject.default)(this._itemByHash);
    (0, _clearObject.default)(this._keysToHash);
  }

  _onAdd(items) {
    const computeHash = this.computeHash,
          itemByHash = this._itemByHash,
          keysToHash = this._keysToHash;

    for (const key in items) {
      const value = items[key];
      const hash = computeHash(value, key);

      if (hash != null) {
        itemByHash[hash] = value;
        keysToHash[key] = hash;
      }
    }
  }

  _onUpdate(items) {
    const computeHash = this.computeHash,
          itemByHash = this._itemByHash,
          keysToHash = this._keysToHash;

    for (const key in items) {
      const value = items[key];
      const prev = keysToHash[key];
      const hash = computeHash(value, key);
      if (prev != null) delete itemByHash[prev];

      if (hash != null) {
        itemByHash[hash] = value;
        keysToHash[key] = hash;
      } else {
        delete keysToHash[key];
      }
    }
  }

  _onRemove(items) {
    const itemByHash = this._itemByHash,
          keysToHash = this._keysToHash;

    for (const key in items) {
      const prev = keysToHash[key];

      if (prev != null) {
        delete itemByHash[prev];
        delete keysToHash[key];
      }
    }
  }

}

exports.UniqueIndex = UniqueIndex;
//# sourceMappingURL=unique-index.js.map